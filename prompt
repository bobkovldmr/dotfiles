#!/bin/zsh

autoload -Uz vcs_info
autoload -U add-zsh-hook
autoload -Uz async && async

setopt PROMPT_SUBST
zstyle ':vcs_info:*' enable git
zstyle ':vcs_info:git:*' formats " %b"

add-zsh-hook precmd precmd_vcs_info
add-zsh-hook precmd __prompt

prompt_line_sep=$'\n'


# prompt_async_taskts(){
#   setopt localoptions noshwordsplit

# 	# initialize async worker
# 	((!${pl_prompt_async_init:-0})) && {
# 		async_start_worker "pl_prompt" -u -n
# 		async_register_callback "pl_prompt" pl_prompt_async_callback
# 		typeset -g pl_prompt_async_init=1
# 	}

#   	typeset -gA pl_prompt_vcs_info

# 	local -H MATCH MBEGIN MEND
# 	if ! [[ $PWD = ${pl_prompt_vcs_info[pwd]}* ]]; then
# 		# stop any running async jobs
# 		async_flush_jobs "pl_prompt"

# 		# reset git preprompt variables, switching working tree
# 		unset pl_prompt_git_dirty
# 		unset pl_prompt_git_last_dirty_check_timestamp
# 		unset pl_prompt_git_arrows
# 		unset pl_prompt_git_fetch_pattern
# 		pl_prompt_vcs_info[branch]=
# 		pl_prompt_vcs_info[top]=
# 	fi
# 	unset MATCH MBEGIN MEND

# 	async_job "pl_prompt" pl_prompt_async_vcs_info $PWD

# 	# # only perform tasks inside git working tree
# 	[[ -n $pl_prompt_vcs_info[top] ]] || return

# 	pl_prompt_async_refresh
# }

# pl_prompt_async_refresh() {
# 	setopt localoptions noshwordsplit

# 	if [[ -z $pl_prompt_git_fetch_pattern ]]; then
# 		# we set the pattern here to avoid redoing the pattern check until the
# 		# working three has changed. pull and fetch are always valid patterns.
# 		typeset -g pl_prompt_git_fetch_pattern="pull|fetch"
# 		async_job "pl_prompt" pl_prompt_async_git_aliases $working_tree
# 	fi

# 	async_job "pl_prompt" pl_prompt_async_git_arrows $PWD

# 	# do not preform git fetch if it is disabled or working_tree == HOME
# 	if (( ${PURE_GIT_PULL:-1} )) && [[ $working_tree != $HOME ]]; then
# 		# tell worker to do a git fetch
# 		async_job "pl_prompt" pl_prompt_async_git_fetch $PWD
# 	fi

# 	# if dirty checking is sufficiently fast, tell worker to check it again, or wait for timeout
# 	integer time_since_last_dirty_check=$(( EPOCHSECONDS - ${pl_prompt_git_last_dirty_check_timestamp:-0} ))
# 	if (( time_since_last_dirty_check > ${PURE_GIT_DELAY_DIRTY_CHECK:-1800} )); then
# 		unset pl_prompt_git_last_dirty_check_timestamp
# 		# check check if there is anything to pull
# 		async_job "pl_prompt" pl_prompt_async_git_dirty ${PL_GIT_UNTRACKED_DIRTY:-1} $PWD
# 	fi
# }

# pl_prompt_async_git_arrows() {
# 	setopt localoptions noshwordsplit
# 	builtin cd -q $1
# 	command git rev-list --left-right --count HEAD...@'{u}'
# }
precmd_vcs_info() { vcs_info }


__format_cwd() {
  local dir_limit="3"
  local truncation="⋯"
  local first_char
  local part_count=0
  local formatted_cwd=""
  local dir_sep="  "
  local tilde="~"

  local cwd="${PWD/#$HOME/$tilde}"

  # get first char of the path, i.e. tilde or slash
  [[ -n ${ZSH_VERSION-} ]] && first_char=$cwd[1,1] || first_char=${cwd::1}

  # remove leading tilde
  cwd="${cwd#\~}"

  while [[ "$cwd" == */* && "$cwd" != "/" ]]; do
    # pop off last part of cwd
    local part="${cwd##*/}"
    cwd="${cwd%/*}"

    formatted_cwd="$dir_sep$part$formatted_cwd"
    part_count=$((part_count+1))

    [[ $part_count -eq $dir_limit ]] && first_char="$truncation" && break
  done

  printf "%s" "$first_char$formatted_cwd"
}

left_prompt() {
  local slice_prefix
  local slice_empty_prefix
  local slice_joiner
  local slice_suffix
  local is_prompt_empty=1

  # section "a" header
  slice_prefix="${a_bg}${sep}${a_fg}${a_bg}${space}"
  slice_suffix="$space${a_sep_fg}"
  slice_joiner="${a_fg}${a_bg}${alt_sep}${space}"
  slice_empty_prefix="${a_fg}${a_bg}${space}"

  [ $is_prompt_empty -eq 1 ] && slice_prefix="$slice_empty_prefix"

  # section "a" slices
  __segment_wrapper "$(__format_cwd)" "$slice_prefix" "$slice_suffix" && { slice_prefix="$slice_joiner"; is_prompt_empty=0; }

  # section "b" header
  slice_prefix="${b_bg}${sep}${b_fg}${b_bg}${space}"
  slice_suffix="$space${b_sep_fg}"
  slice_joiner="${b_fg}${b_bg}${alt_sep}${space}"
  slice_empty_prefix="${b_fg}${b_bg}${space}"

  [ $is_prompt_empty -eq 1 ] && slice_prefix="$slice_empty_prefix"

  # section "b" slices
  __segment_wrapper "$(vcs_branch)" "$slice_prefix" "$slice_suffix" && { slice_prefix="$slice_joiner"; is_prompt_empty=0; }

  # section "c" header
  slice_prefix="${c_bg}${sep}${c_fg}${c_bg}${space}"
  slice_suffix="$space${c_sep_fg}"
  slice_joiner="${c_fg}${c_bg}${alt_sep}${space}"
  slice_empty_prefix="${c_fg}${c_bg}${space}"

  [ $is_prompt_empty -eq 1 ] && slice_prefix="$slice_empty_prefix"

  # section "c" slices
  __segment_wrapper "$(__async_git_status)" "$slice_prefix" "$slice_suffix" && { slice_prefix="$slice_joiner"; is_prompt_empty=0; }

  printf "%s" "${reset_bg}${sep}$reset$space${prompt_line_sep}\$$space"
}

__segment_wrapper() {
  # wrap the text in $1 with $2 and $3, only if $1 is not empty
  # $2 and $3 typically contain non-content-text, like color escape codes and separators

  [[ -n "$1" ]] || return 1
  printf "%s" "${2}${1}${3}"
}

# Get branch
vcs_branch() {
  printf "${vcs_info_msg_0_}"
}

# Gets git diff status
__async_git_status() {
  [[ $(git rev-parse --is-inside-work-tree 2>/dev/null) == true ]] || return 1

  local added_symbol="●"
  local unmerged_symbol="ⅹ"
  local modified_symbol="+"
  local clean_symbol=""
  local has_untracked_files_symbol="…"

  local ahead_symbol="↑"
  local behind_symbol="↓"

  local unmerged_count=0 modified_count=0 has_untracked_files=0 added_count=0 is_clean=""

  set -- $(git rev-list --left-right --count @{upstream}...HEAD 2>/dev/null)
  local behind_count=$1
  local ahead_count=$2

  # Added (A), Copied (C), Deleted (D), Modified (M), Renamed (R), changed (T), Unmerged (U), Unknown (X), Broken (B)
  while read line; do
    case "$line" in
      M*) modified_count=$(( $modified_count + 1 )) ;;
      U*) unmerged_count=$(( $unmerged_count + 1 )) ;;
    esac
  done < <(git diff --name-status)

  while read line; do
    case "$line" in
      *) added_count=$(( $added_count + 1 )) ;;
    esac
  done < <(git diff --name-status --cached)

  if [ -n "$(git ls-files --others --exclude-standard)" ]; then
    has_untracked_files=1
  fi

  if [ $(( unmerged_count + modified_count + has_untracked_files + added_count )) -eq 0 ]; then
    is_clean=1
  fi

  local leading_whitespace=""
  [[ $ahead_count -gt 0 ]]         && { printf "%s" "$leading_whitespace$ahead_symbol$ahead_count"; leading_whitespace=" "; }
  [[ $behind_count -gt 0 ]]        && { printf "%s" "$leading_whitespace$behind_symbol$behind_count"; leading_whitespace=" "; }
  [[ $modified_count -gt 0 ]]      && { printf "%s" "$leading_whitespace$modified_symbol$modified_count"; leading_whitespace=" "; }
  [[ $unmerged_count -gt 0 ]]      && { printf "%s" "$leading_whitespace$unmerged_symbol$unmerged_count"; leading_whitespace=" "; }
  [[ $added_count -gt 0 ]]         && { printf "%s" "$leading_whitespace$added_symbol$added_count"; leading_whitespace=" "; }
  [[ $has_untracked_files -gt 0 ]] && { printf "%s" "$leading_whitespace$has_untracked_files_symbol"; leading_whitespace=" "; }
  [[ $is_clean -gt 0 ]]            && { printf "%s" "$leading_whitespace$clean_symbol"; leading_whitespace=" "; }
}

__prompt() {
  local esc=$'['
  local end_esc=m
  local noprint='%{'
  local end_noprint='%}'
  local wrap="$noprint$esc"
  local end_wrap="$end_esc$end_noprint"
  local space=" "
  local sep=""
  local rsep=""
  local alt_sep=""
  local alt_rsep=""
  local reset="${wrap}0${end_wrap}"
  local reset_bg="${wrap}49${end_wrap}"

  local a_fg="${wrap}38;5;015${end_wrap}"
  local a_bg="${wrap}48;5;4${end_wrap}"
  local a_sep_fg="${wrap}38;5;4${end_wrap}"

  local b_fg="${wrap}38;5;7${end_wrap}"
  local b_bg="${wrap}48;5;237${end_wrap}"
  local b_sep_fg="${wrap}38;5;237${end_wrap}"

  local c_fg="${wrap}38;5;7${end_wrap}"
  local c_bg="${wrap}48;5;238${end_wrap}"
  local c_sep_fg="${wrap}38;5;238${end_wrap}"

  PROMPT="$(left_prompt)"
}
